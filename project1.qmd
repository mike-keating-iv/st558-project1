---
title: "Project 1"
author: "Mike Keating, Hayden Morgan"
format: pdf
editor: visual
---

# Project 1

## First Steps

```{r}
# Dependencies
#| warnings: false
#| messages: false
suppressWarnings(library("tidyverse"))
suppressWarnings(library("ggplot2"))
```

Here we can first attempt each task/question and then refactor into functions later.

## Question 1

Read in one section of the data. This data is available at <https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv>.

Select only the following columns:

-   Area_name (rename area_name)

-   STCOU

-   Any column that ends in "D"

```{r}
#NOTE: The file has been downloaded and is in our data folder 
# TODO: Read data
# TODO: Hayden

edu01a <- read_csv("data/EDU01a.csv", col_select = c(Area_name, STCOU, ends_with("D")), show_col_types = FALSE) |>
  rename(
    area_name = Area_name
  )

```

Display the first 5 rows of your new data set to show that you created this correctly. Note: Do not save over your new data set with just the first 5 rows, simply just show the first 5 rows.

```{r}

head(edu01a, 5)

```

## Question 2

Convert the data into long format where each row has only one enrollment value for that Area_name. Display the first 5 rows of your new data set to show that you created this correctly.

```{r}
# TODO: Convert to long format
# Hayden

edu01a_long <- edu01a |>
                  pivot_longer(cols = 3:12,
                               names_to = "EDU_D",
                               values_to = "Enrollment")

head(edu01a_long, 5)
```

## Question 3

One of the new columns should now correspond to the old column names that end with a “D”. All columns in these census data files will have this similar format. The first three characters represent the survey with the next four representing the type of value you have from that survey. The last two digits prior to the “D” represent the year of the measurement. For more about the variables see the data information sheet Mastdata.xls).

-   Parse the string to pull out the year and convert the year into a numeric value such as 1997 or 2002.

-   Grab the first three characters and following four digits to create a new variable representing which measurement was grabbed.

-   Hint: Check out the substr() function from base r

    ```{r}
    # TODO: Mike

    # Parse the string to pull out year
    # It looks like every year is pre-2000, but lets plan for up to 2025
    # This assumes there is no data from 1925 or earlier
    # Treating year as numeric for now
    long_updated <- edu01a_long |> mutate(year = as.numeric(substr(EDU_D, 8,9)), measurement = substr(EDU_D, 1,7)) |> 
      mutate(year = ifelse(year < 26, year + 2000, year + 1900))

    head(long_updated)

    ```

## Question 4

Create two data sets

-   one data set that contains only non-county data

-   one data set that contains only county level data

Note that all county measurements have the format “County Name, DD” where “DD” represents the state. This can be used to subset the data. I used the code grep(pattern = ", \\w\\w", Area_name) to get the indices corresponding to counties. For the county level data, add a class to the tibble called county. Similarly, add a class to the non-county data called state. This can be done by overwriting the class() you see on the object: class(your_county_tibble) <- c("county", class(your_county_tibble))

For the county level data, add a class to the tibble called county. Similarly, add a class to the non-county data called state. This can be done by overwriting the class() you see on the object:

```{r}
#For county tibble
county_match <- grep(pattern = ", \\w\\w", long_updated$area_name)
county_tibble <- long_updated[county_match,]
class(county_tibble) <- c("county", class(county_tibble))

#For state tibble
state_match <- grep(pattern = ", \\w\\w", long_updated$area_name, invert = T)
state_tibble <- long_updated[state_match,]
class(state_tibble) <- c("state", class(state_tibble))

```

Print the first 10 rows of each tibble by including county_tibble and state_tibble in your code chunk.

```{r}
# TODO Hayden

head(county_tibble, 10)
head(state_tibble, 10)

```

## Question 5

For the county level tibble, create a new variable that describes which state one of these county measurements corresponds to (the two digit abbreviation is fine, see substr()).

```{r}
# TODO: Create state variable
# Mike
```

## Question 6

For the non-county level tibble, create a new variable called “division” corresponding to the state’s classification of division [here.](https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States) If row corresponds to a non-state (i.e. UNITED STATES), return ERROR for the division. Hint: Use %in% and consider if_else or case_when logic.

We can scrape a wikipedia table using the rvest package.

Source: [StackOverflow](https://stackoverflow.com/questions/73696551/r-webscraping-error-arguments-imply-differing-number-of-rows)

```{r}
# To do: Mike
library(rvest) # rvest is in the tidyverse package
# 

# Since we don't want to always have to connect to the url to read our data, 
# let's check if we have already saved it
if (file.exists("data/divisions.csv")){
  print("Division data already downloaded")
  print("Reading .csv file")
  divisions <- read_csv("data/divisions.csv")
} else {
  print("No division data found. Downloading from Wikipedia...")
  wiki <- read_html(x = "https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States", package="xml2")
  wiki |> html_elements(".wikitable") |> html_table() -> wiki_tables
  # There is only one table, so the first one will give us what we want
  divisions <- wiki_tables[1]
  # Write the file to csv
  write.csv(divisions, file= "data/divisions.csv")
  print("data/divisions.csv successfully created!")
}

divisions

```

Note how all states in any given region are stored in the same cell, separated by spaces. We can either transform the States column by splitting up the states or leave as is and process the state correctly when reading our other datasets.

```{r}
# TODO: Assign division based on the state-division pairs we read in
```

## Function Wrapping

### Function 1

Write one function that combines Questions 1 and 2 above. Give an optional argument (that is it has a default value) that allows the user to specify the name of the column representing the value (enrollment for these data sets).

```{r}

select_and_convert <- function(data_path_in_quotes, value_colname = "Enrollment"){
  edu <- read_csv(data_path_in_quotes, col_select = c(Area_name, STCOU, ends_with("D")), show_col_types = FALSE) |>
  rename(
    area_name = Area_name
  )
  
  edu_long <- edu |>
                pivot_longer(cols = 3:12,
                             names_to = "EDU_D",
                             values_to = value_colname)
  
  return(head(edu_long, 5))
}

select_and_convert("data/EDU01b.csv")

```


### Function 2

Write a function that takes the output from Question 2 and performs Question 3

```{r}

get_year_and_measurement <- function(df){
  
   return(
     df |> 
       mutate(year = as.numeric(substr(EDU_D, 8,9)), measurement = substr(EDU_D, 1,7)) |>
       mutate(year = ifelse(year < 26, year + 2000, year + 1900))
     )
  
}

get_year_and_measurement(edu01a_long)
```

### Function 3

Write a function to do Question 5

### Function 4

Write a function to do step 6

### Function 5

Write another function that takes in the output from Question 3 and creates the two tibbles in Question 4, calls the above two functions (to perform Questions 5 and 6), and returns two final tibbles.Wrap everything into one function call

## Wrap Everything in One Function Call

## Call It and Combine Data

## Write Generic Function for Summarizing

## Put It Together
